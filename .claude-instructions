# 프로젝트 코드 컨벤션 및 규칙

## 기술 스택
- Expo 53.0.11 (Expo Router 사용)
- TypeScript
- Zustand (전역 상태 관리)
- Supabase (백엔드)
- React Hook Form + Zod (폼 검증)
- TanStack Query (서버 상태 관리)
- NativeWind (Tailwind for React Native)
- SQLite (로컬 데이터베이스)

## 필수 폴더 구조
프로젝트/
├── app/                          # Expo Router 전용 (라우팅만)
│   ├── _layout.tsx              # 공통 레이아웃
│   ├── index.tsx                # 홈 화면
│   └── [도메인]/                # 도메인별 라우팅
│       ├── index.tsx            # 목록 화면
│       ├── create.tsx           # 생성 화면
│       └── [id].tsx             # 상세 화면 (다이나믹 라우팅)
│
├── src/
│   ├── features/                # 도메인별 기능 모듈
│   │   └── [도메인]/           # 예: memory, user, settings
│   │       ├── components/     # 도메인 전용 컴포넌트
│   │       ├── screens/        # 화면 컴포넌트
│   │       ├── hooks/          # 도메인 전용 훅
│   │       ├── services.ts     # API/DB CRUD 함수
│   │       ├── store.ts        # Zustand 스토어
│   │       └── types.ts        # 타입 정의
│   │
│   ├── components/              # 공통 컴포넌트
│   │   ├── ui/                 # Button, Card, Modal 등
│   │   └── layouts/            # ScreenContainer, Header 등
│   │
│   ├── hooks/                   # 공통 커스텀 훅
│   ├── lib/                     # 유틸리티
│   │   ├── db/                 # SQLite 관련
│   │   └── storage.ts          # AsyncStorage 래퍼
│   ├── store/                   # 글로벌 스토어
│   ├── constants/               # 전역 상수
│   └── types/                   # 전역 타입
│
└── assets/                      # 이미지, 폰트 등

## 네이밍 규칙 (반드시 준수)

### 파일 및 폴더
- **파일명**: kebab-case → `user-profile.tsx`
- **폴더명**: kebab-case → `user-management/`

### 컴포넌트 및 함수
- **컴포넌트명**: PascalCase → `UserProfile`
- **컴포넌트 파일 내 선언**: 파일명과 다르게 PascalCase 사용
```tsx
// user-profile.tsx 파일
const UserProfile = () => { ... }
export default UserProfile
변수 및 상수

변수: camelCase → const userName
복수형: s 붙이기 → const users
상수: UPPER_SNAKE_CASE → const API_BASE_URL
DB ID: camelCase로 변환 → user_id → userId

타입

타입명: PascalCase + Type 접미사 → UserType, MemoryItemType
Props 타입: PascalCase + Props 접미사 → UserCardProps

컴포넌트 작성 규칙
기본 구조 (반드시 이 형태 사용)
tsx// user-card.tsx
type UserCardProps = {
  name: string;
  age?: number;
  isActive?: boolean;
};

const UserCard = ({ name, age = 0, isActive = false }: UserCardProps) => {
  // 로직 작성
  
  return (
    <View>
      <Text>{name}</Text>
    </View>
  );
};

export default UserCard; // 항상 파일 최하단
컴포넌트 접미사 규칙

[Name]Page: 전체 화면 컴포넌트 → UserListPage
[Name]Layout: 레이아웃 컴포넌트 → MainLayout
[Name]Container: 여러 요소 감싸기 → UserListContainer
[Name]Wrapper: 단일 요소 감싸기 → ButtonWrapper

API 함수 네이밍 (services.ts)
RESTful API 함수
tsx// GET: fetchGet + 테이블명
export const fetchGetUsers = async () => { ... }
export const fetchGetUserById = async (id: string) => { ... }

// POST: fetchCreate + 테이블명
export const fetchCreateUser = async (data: UserType) => { ... }

// PUT/PATCH: fetchUpdate + 테이블명
export const fetchUpdateUser = async (id: string, data: UserType) => { ... }

// DELETE: fetchDelete + 테이블명
export const fetchDeleteUser = async (id: string) => { ... }
상태 관리 네이밍
Zustand Store
tsx// use[도메인]Store 형태
export const useUserStore = create<UserStoreType>((set) => ({
  users: [],
  setUsers: (users) => set({ users }),
  currentUser: null,
  setCurrentUser: (user) => set({ currentUser: user })
}));

// 사용시 selector 패턴 필수
const users = useUserStore((state) => state.users);
const setUsers = useUserStore((state) => state.setUsers);
TanStack Query
tsx// Query: use[도메인]Query
export const useUsersQuery = () => {
  return useQuery({
    queryKey: ['users'],
    queryFn: fetchGetUsers,
    staleTime: 10 * 1000
  });
};

// Mutation: use[행동][도메인]Mutation
export const useCreateUserMutation = () => {
  return useMutation({
    mutationFn: fetchCreateUser,
    onSuccess: () => {
      // 성공 처리
    }
  });
};

export const useUpdateUserMutation = () => { ... }
export const useDeleteUserMutation = () => { ... }
필수 코딩 규칙
1. 함수는 모두 Arrow Function
tsx// ✅ 올바른 예
const handlePress = () => { ... }
const calculateSum = (a: number, b: number) => a + b

// ❌ 잘못된 예
function handlePress() { ... }
2. Export 규칙
tsx// 일반 함수: export만 사용
export const utilityFunction = () => { ... }

// 컴포넌트: export default를 파일 최하단에
const MyComponent = () => { ... }
export default MyComponent
3. if문 처리
tsx// Early return 패턴 사용
if (!user) {
  return null;
}

if (isLoading) {
  return <LoadingSpinner />;
}
4. 비동기 처리
tsx// async/await 사용 (Promise 체이닝 금지)
const fetchData = async () => {
  try {
    const response = await fetch('/api/data');
    if (!response.ok) throw new Error('Failed');
    return await response.json();
  } catch (error) {
    console.error(error);
    throw error;
  }
};
5. JSDoc 주석
tsx/**
 * 사용자 정보를 조회합니다
 * @param userId - 조회할 사용자 ID
 * @param includeDetails - 상세 정보 포함 여부
 * @returns 사용자 정보 객체
 */
export const fetchGetUserById = async (userId: string, includeDetails = false): Promise<UserType> => {
  // 구현
};
타입 정의 규칙
기본 타입
tsx// types.ts
export type UserType = {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
};

// Props 타입은 컴포넌트 파일에 정의
type ComponentNameProps = {
  user: UserType;
  onPress?: () => void;
};
DB 타입
tsx// d.ts 파일 사용
type Tables<T extends keyof Database> = Database[T]['Row'];
type UserRow = Tables<'users'>;
코드 작성 우선순위

타입 안정성: 모든 변수, 함수, props에 타입 정의
네이밍 일관성: 위 규칙 100% 준수
코드 재사용성: 중복 코드를 공통 컴포넌트/함수로 추출
성능 최적화: memo, useMemo, useCallback 적절히 사용
가독성: 명확한 변수명, 적절한 주석

리팩토링 체크리스트
변경 전 반드시 확인:

 파일명이 kebab-case인가?
 컴포넌트명이 PascalCase인가?
 export default가 파일 최하단에 있는가?
 모든 함수가 arrow function인가?
 API 함수명이 fetchGet/Create/Update/Delete 패턴인가?
 Zustand store가 use[도메인]Store 형태인가?
 Query hook이 use[도메인]Query 형태인가?
 Props 타입이 정의되어 있는가?
 JSDoc 주석이 필요한 곳에 있는가?

금지 사항

❌ function 키워드 사용 금지
❌ var 사용 금지 (const, let만 사용)
❌ any 타입 사용 최소화
❌ 컴포넌트 내 직접 스타일 정의 금지 (NativeWind 사용)
❌ Promise.then() 체이닝 금지 (async/await 사용)